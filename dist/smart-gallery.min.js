class SmartGallery {constructor(container, options = {}) {this.container = typeof container === 'string' ? document.querySelector(container) : container;if (!this.container) {throw new Error('SmartGallery: Container not found.');}this.options = Object.assign({layout: 'justified',gap: 10,targetRowHeight: 300,lastRowBehavior: 'hide',columnWidth: 300,columns: 'auto',className: '',itemClassName: 'sg-item',virtualize: true,buffer: 500,placeholderColor: '#eee',renderItem: null,onItemClick: null}, options);this.items = [];this.geometry = [];this.renderedIndices = new Set();this.resizeObserver = null;this.scrollHandler = null;this.isResizing = false;this._init();}_init() {this.container.style.position = 'relative';this.container.classList.add('smart-gallery');if (this.options.className) {this.container.classList.add(this.options.className);}let resizeTimeout;this.resizeObserver = new ResizeObserver(() => {if (this.isResizing) return;clearTimeout(resizeTimeout);resizeTimeout = setTimeout(() => {this.render();}, 100);});this.resizeObserver.observe(this.container);if (this.options.virtualize) {this.scrollHandler = this._throttle(this._handleScroll.bind(this), 50);window.addEventListener('scroll', this.scrollHandler, { passive: true });}}addItems(items) {const newItems = items.map(item => {let aspectRatio = item.aspectRatio;if (!aspectRatio && item.width && item.height) {aspectRatio = item.width / item.height;}if (!aspectRatio) {aspectRatio = 1;}return { ...item, aspectRatio };});this.items = [...this.items, ...newItems];}render() {if (!this.container || this.items.length === 0) return;this.isResizing = true;const containerWidth = this.container.clientWidth;const { layout } = this.options;let containerHeight = 0;this.renderedIndices.clear();this.container.innerHTML = '';this.geometry = [];let result;if (layout === 'justified') {result = this._computeJustifiedLayout(this.items, containerWidth, this.options);} else if (layout === 'masonry') {result = this._computeMasonryLayout(this.items, containerWidth, this.options);} else if (layout === 'grid') {result = this._computeGridLayout(this.items, containerWidth, this.options);}this.geometry = result.boxes.map((box, i) => ({ ...box, itemIndex: i }));containerHeight = result.containerHeight;this.container.style.height = `${containerHeight}px`;this._updateVisibleItems();this.isResizing = false;}_updateVisibleItems() {if (!this.options.virtualize) {this._renderItems(this.geometry);return;}const scrollTop = window.scrollY;const viewportHeight = window.innerHeight;const buffer = this.options.buffer;const rect = this.container.getBoundingClientRect();const containerTop = rect.top + scrollTop;const startY = Math.max(0, scrollTop - containerTop - buffer);const endY = scrollTop - containerTop + viewportHeight + buffer;const indicesToRender = new Set();this.geometry.forEach((box) => {if (box.top + box.height > startY && box.top < endY) {indicesToRender.add(box.itemIndex);}});indicesToRender.forEach(index => {if (!this.renderedIndices.has(index)) {this._mountItem(this.geometry[index]);this.renderedIndices.add(index);}});this.renderedIndices.forEach(index => {if (!indicesToRender.has(index)) {this._unmountItem(index);this.renderedIndices.delete(index);}});}_mountItem(box) {const index = box.itemIndex;const itemData = this.items[index];const div = document.createElement('div');div.className = this.options.itemClassName;div.id = `sg-item-${index}`;div.style.position = 'absolute';div.style.left = `${box.left}px`;div.style.top = `${box.top}px`;div.style.width = `${box.width}px`;div.style.height = `${box.height}px`;if (this.options.renderItem) {div.appendChild(this.options.renderItem(itemData, index));} else {div.style.backgroundColor = itemData.placeholderColor || this.options.placeholderColor;const img = document.createElement('img');img.src = itemData.src;img.style.width = '100%';img.style.height = '100%';img.style.objectFit = 'cover';img.style.display = 'block';img.style.opacity = '0';img.style.transition = 'opacity 0.3s';img.loading = 'lazy';img.onload = () => {img.style.opacity = '1';};div.appendChild(img);}div.addEventListener('click', (event) => {if (this.options.onItemClick) {this.options.onItemClick({ index, itemData, originalEvent: event });}});this.container.appendChild(div);}_unmountItem(index) {const el = this.container.querySelector(`#sg-item-${index}`);if (el) {el.remove();}}_handleScroll() {if (!this.isResizing) {requestAnimationFrame(() => this._updateVisibleItems());}}_throttle(func, limit) {let inThrottle;return function() {const args = arguments;const context = this;if (!inThrottle) {func.apply(context, args);inThrottle = true;setTimeout(() => inThrottle = false, limit);}}}_computeJustifiedLayout(items, containerWidth, options) {const { targetRowHeight, gap, lastRowBehavior } = options;const boxes = [];let top = 0;const aspectRatios = items.map(item => item.aspectRatio);function calculateRow(startIndex, endIndex) {const rowItems = [];let totalAspect = 0;for (let i = startIndex; i <= endIndex; i++) {totalAspect += aspectRatios[i];}const count = endIndex - startIndex + 1;const totalGap = (count - 1) * gap;const availableWidth = containerWidth - totalGap;const rowHeight = availableWidth / totalAspect;return { rowHeight, score: Math.pow(Math.abs(rowHeight - targetRowHeight), 2) };}let i = 0;while (i < items.length) {let rowItems = [];let currentAspect = 0;let bestBreakIndex = -1;let minScore = Infinity;let j = i;while (j < items.length) {currentAspect += aspectRatios[j];const count = j - i + 1;const totalGap = (count - 1) * gap;const availableWidth = containerWidth - totalGap;const rowHeight = availableWidth / currentAspect;if (rowHeight < targetRowHeight * 0.5) break;const score = Math.abs(rowHeight - targetRowHeight);if (score < minScore) {minScore = score;bestBreakIndex = j;}j++;}if (bestBreakIndex !== -1) {const isLastRow = bestBreakIndex === items.length - 1;let finalRowHeight = 0;let finalRowItemsCount = bestBreakIndex - i + 1;let finalAspect = 0;for (let k = i; k <= bestBreakIndex; k++) {finalAspect += aspectRatios[k];}const totalGap = (finalRowItemsCount - 1) * gap;finalRowHeight = (containerWidth - totalGap) / finalAspect;if (isLastRow) {if (lastRowBehavior === 'hide') {break;} else if (lastRowBehavior === 'no-justify') {finalRowHeight = targetRowHeight;}}let left = 0;for (let k = i; k <= bestBreakIndex; k++) {const w = finalRowHeight * aspectRatios[k];boxes.push({left: left,top: top,width: w,height: finalRowHeight});left += w + gap;}top += finalRowHeight + gap;i = bestBreakIndex + 1;} else {const w = targetRowHeight * aspectRatios[i];boxes.push({left: 0, top: top, width: w, height: targetRowHeight});top += targetRowHeight + gap;i++;}}return { boxes, containerHeight: top };}_computeMasonryLayout(items, containerWidth, options) {const { gap, columnWidth, columns } = options;let colCount = 0;let colW = 0;if (columns === 'auto') {colW = columnWidth;colCount = Math.floor((containerWidth + gap) / (colW + gap));colCount = Math.max(1, colCount);colW = (containerWidth - (colCount - 1) * gap) / colCount;} else {colCount = columns;colW = (containerWidth - (colCount - 1) * gap) / colCount;}const colHeights = new Array(colCount).fill(0);const boxes = [];items.forEach(item => {const minH = Math.min(...colHeights);const colIndex = colHeights.indexOf(minH);const h = colW / item.aspectRatio;boxes.push({left: colIndex * (colW + gap),top: minH,width: colW,height: h});colHeights[colIndex] += h + gap;});return { boxes, containerHeight: Math.max(...colHeights) };}_computeGridLayout(items, containerWidth, options) {const { gap, columnWidth, columns } = options;let colCount = 0;let colW = 0;if (columns === 'auto') {colW = columnWidth;colCount = Math.floor((containerWidth + gap) / (colW + gap));colCount = Math.max(1, colCount);colW = (containerWidth - (colCount - 1) * gap) / colCount;} else {colCount = columns;colW = (containerWidth - (colCount - 1) * gap) / colCount;}const itemH = colW;const boxes = [];items.forEach((item, i) => {const colIndex = i % colCount;const rowIndex = Math.floor(i / colCount);boxes.push({left: colIndex * (colW + gap),top: rowIndex * (itemH + gap),width: colW,height: itemH});});const rows = Math.ceil(items.length / colCount);return { boxes, containerHeight: rows * (itemH + gap) - gap };}destroy() {if (this.resizeObserver) {this.resizeObserver.disconnect();}if (this.scrollHandler) {window.removeEventListener('scroll', this.scrollHandler);}}}(function (root, factory) {if (typeof define === 'function' && define.amd) {define([], factory);} else if (typeof module === 'object' && module.exports) {module.exports = factory();} else {root.SmartGallery = factory();}}(typeof self !== 'undefined' ? self : this, function () {return SmartGallery;}));